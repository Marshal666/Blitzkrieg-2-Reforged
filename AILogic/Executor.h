#pragma once
#include "..\Stats_b2_m1\RpgStats.h"

class CExecutor;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
extern interface IExecutorContainer * pTheExecutorsContainer;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum EExecutorTypeID
{
	TID_NONE										= 0,
	TID_STATIC_OBJECT_SEGMENT		= 1,
	TID_TRANSPORT_HEAL_INFANTRY = 2,
	TID_SNIPER_CAMOUFLAGE				= 3,
	TID_THROW_GRENADE						= 4,
	TID_PLACE_CHARGE            = 5,
	TID_SOLDIER_ENTRENCH_SELF		= 6,
	TID_PLANE_DROP_BOMBS_OBJECT	= 7,
	TID_PLANE_DROP_BOMBS_AREA		= 8,
	TID_RESTORE_TRANSPARENCY		= 9,
	TID_AMBUSH									= 10,
	TID_BONUS										= 11,
	TID_ADRENALINE_RUSH					= 12,
	TID_CAUTION									= 13,
	TID_COUNTER_FIRE						= 14,
	TID_EXACT_SHOT							= 15,
	TID_FIRST_AID								= 16,
	TID_MOVE_BY_FORMATION				= 17,
	TID_CAMOUFLAGE							= 18,
	TID_SMOKE_SHOTS							= 19,
	TID_LINKED_GRENADES					= 20,
	TID_TRACK_TARGETTING				= 21,
	TID_SPY_MODE								= 22,
	TID_TIMED_CHARGE						= 23,
	TID_FAKE_CORPSE							= 24,
	TID_ALLOW_FAKE_OBJ_TO_CRUSH = 25,
	TID_TRANSPORT_REINFORCEMENT	= 26,
	TID_TRANSPORT_LOOK_FOR_ENEMY_UNLOAD_INFANTRY = 27,
	// attack group
	TID_ATTACKGROUP							= 28,
	TID_BURNING_FUEL						= 29,
	// super weapon contorller
	TID_SUPER_WEAPON						= 30,

	_TID_COUNT,
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum EExecutorEventID
{
	EID_ABILITY_ACTIVATE,									// event when ability with nonzero group run (all abilities from this group are disabled)
	EID_ABILITY_DEACTIVATE,
	EID_ABILITY_DISABLE,
	EID_ABILITY_ENABLE,
	EID_ABILITY_ACTIVATE_AUTOCAST,
	EID_ABILITY_DEACTIVATE_AUTOCAST,

	EID_ABILITY_SET_TARGET,

	EID_START_MOVE,
	EID_START_IDLE,
	EID_STOP_IDLE,

	// CAMOFLAGE
	EID_FIRE_CAMOFLATED,
	EID_NEW_COMMAND_RECIEVED,

	EID_ADD_TO_RESTORE_TRANSPARENCY_QUEUE,

	EID_TERMINATE_STATE,
	// attack point 
	EID_ATTACKGROUP_ADD_UNIT,
	EID_ATTACKGROUP_ATTACK,
	EID_ATTACKGROUP_DELETE,
	// 
	EID_SUPER_WEAPON_INITIALIZE,
	EID_SUPER_WEAPON_CONTROL,
	EID_SUPER_WEAPON_USE,

	_EID_COUNT = 1,
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// event. in ideal world events are generated only by executors.
// but in a7 & b2 mix events may be generated by LinkObject and by Executor
struct SExecutorEventParam
{
	ZDATA
	EExecutorEventID eEventID;							// what event 
	int nExecutorID;												// for executor generated event
	int nUnitID;														// for unit generated event (legacy)
public: 
	ZEND int operator&( IBinSaver &f ) { f.Add(2,&eEventID); f.Add(3,&nExecutorID); f.Add(4,&nUnitID); return 0; }
	SExecutorEventParam() : eEventID( (EExecutorEventID)0 ), nExecutorID( 0 ), nUnitID( 0 ) { }
	SExecutorEventParam( const EExecutorEventID _eEventID, const int _nExecutorID, const int _nUnitID )
		: eEventID( _eEventID ), nExecutorID( _nExecutorID ), nUnitID( _nUnitID )
	{
	}

	virtual const class CAICommand * GetCommand() const { return 0; }
	bool operator==( const SExecutorEventParam &param ) const
	{
		return 0 == memcmp( this, &param, sizeof(*this) );
	}
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// all events extends this class.
class CExecutorEvent
{
	ZDATA
	SExecutorEventParam param;
public:
	ZEND int operator&( IBinSaver &f ) { f.Add(2,&param); return 0; }

public:
	CExecutorEvent( const SExecutorEventParam &_param ) : param( _param ) {  }
	CExecutorEvent() {  }
	const SExecutorEventParam &GetParam() const { return param; }

	void SetParam( const SExecutorEventParam &_param ) { param = _param; }

};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// object added to restore transparency queue. 
// all objects around this object will set their transparency again.
class CExecutorEventAddToRestoreTransparencyQueue : public CExecutorEvent
{
	int nID;
public:
	CExecutorEventAddToRestoreTransparencyQueue( const SExecutorEventParam &_param, const int _nID ) 
		: nID( _nID ), CExecutorEvent( _param )
	{
	}
	const int GetID() const { return nID; }
	int operator&( IBinSaver &saver )
	{
		saver.Add( 1, static_cast<CExecutorEvent*>( this ) );
		saver.Add( 2, &nID );
		return 0;
	}
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CExecutorEventSpecialAbilityActivate : public CExecutorEvent
{
	ZDATA_(CExecutorEvent)
	NDb::EUnitSpecialAbility eAbility;
	CDBPtr<NDb::SUnitSpecialAblityDesc> pDesc;
	CPtr<CAICommand> pCommand;
	ZEND int operator&( IBinSaver &f ) { f.Add(1,(CExecutorEvent*)this); f.Add(2,&eAbility); f.Add(3,&pDesc); f.Add(4,&pCommand); return 0; }
public:

	const CAICommand * GetCommand() const { return pCommand; }
	const NDb::SUnitSpecialAblityDesc * GetDesc() const { return pDesc; }
	const NDb::EUnitSpecialAbility GetAbility() const { return eAbility; }

	CExecutorEventSpecialAbilityActivate() {  }
	CExecutorEventSpecialAbilityActivate( const SExecutorEventParam &_param, 
																				const NDb::EUnitSpecialAbility _eAbility,
																				class CAICommand *_pCommand,
																				const NDb::SUnitSpecialAblityDesc *_pDesc )
		: CExecutorEvent( _param ), pDesc( _pDesc ), eAbility( _eAbility ), pCommand( _pCommand )
	{
	}
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CExecutorEventSpecialAbilityDeactivate : public CExecutorEvent
{
	ZDATA_(CExecutorEvent)
	NDb::EUnitSpecialAbility eAbility;
	ZEND int operator&( IBinSaver &f ) { f.Add(1,(CExecutorEvent*)this); f.Add(2,&eAbility); return 0; }
public:
	const NDb::EUnitSpecialAbility GetAbility() const { return eAbility; }

	CExecutorEventSpecialAbilityDeactivate() {  }
	CExecutorEventSpecialAbilityDeactivate( const SExecutorEventParam &param, 
		const NDb::EUnitSpecialAbility _eAbility )
		: CExecutorEvent( param ), eAbility( _eAbility )
	{
	}
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CExecutorEventSpecialAbility : public CExecutorEvent
{
	ZDATA_(CExecutorEvent)
	NDb::EUnitSpecialAbility eAbility;
public:
	ZEND int operator&( IBinSaver &f ) { f.Add(1,(CExecutorEvent*)this); f.Add(2,&eAbility); return 0; }
public:
	const NDb::EUnitSpecialAbility GetAbility() const { return eAbility; }

	CExecutorEventSpecialAbility() {  }
	CExecutorEventSpecialAbility( const SExecutorEventParam &param, 
		const NDb::EUnitSpecialAbility _eAbility )
		: CExecutorEvent( param ), eAbility( _eAbility )
	{
	}

};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CExecutorEventSpecialAbilitySetTarget : public CExecutorEventSpecialAbility
{
	ZDATA_(CExecutorEventSpecialAbility)
	CVec2 vCoords;
	CDBPtr<NDb::SHPObjectRPGStats> pTarget;
public:
	ZEND int operator&( IBinSaver &f ) { f.Add(1,(CExecutorEventSpecialAbility*)this); f.Add(2,&vCoords); f.Add(3,&pTarget); return 0; }

public:
	CExecutorEventSpecialAbilitySetTarget() {  }
	CExecutorEventSpecialAbilitySetTarget( const SExecutorEventParam &param, 
		const NDb::EUnitSpecialAbility _eAbility, const CVec2 _vCoords )
		: CExecutorEventSpecialAbility( param, _eAbility ), vCoords( _vCoords )
	{	}
	CExecutorEventSpecialAbilitySetTarget( const SExecutorEventParam &param, 
		const NDb::EUnitSpecialAbility _eAbility, const NDb::SHPObjectRPGStats *_pTarget )
		: CExecutorEventSpecialAbility( param, _eAbility ), vCoords( VNULL2 ), pTarget(_pTarget)
	{	}
	const CVec2 GetTargetCoords() const { return vCoords; }
	const NDb::SHPObjectRPGStats *GetTarget() const { return pTarget; }
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CExecutorEventSuperWeaponControl : public CExecutorEvent
{
	ZDATA_( CExecutorEvent )
		int nPlayer;
		int nUnitID;
		bool bEnabled;
public:
	ZEND int operator&( IBinSaver &f ) { f.Add(1,( CExecutorEvent *)this); f.Add(2,&nPlayer); f.Add(3,&nUnitID); f.Add(4,&bEnabled); return 0; }

	CExecutorEventSuperWeaponControl() : nPlayer( -1 ), bEnabled( false ), nUnitID( -1 ) {}
	CExecutorEventSuperWeaponControl( const int _nPlayer, const bool _bEnabled, const int _nUnitID )
		: CExecutorEvent( SExecutorEventParam( EID_SUPER_WEAPON_CONTROL, -1, -1 ) ), nPlayer( _nPlayer ), bEnabled( _bEnabled ), nUnitID( _nUnitID ) {}

	const int GetPlayer() const { return nPlayer; }
	const bool IsEnabled() const { return bEnabled; }
	const int GetUnitID() const { return nUnitID; } 
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CExecutorEventSuperWeaponUse : public CExecutorEvent
{
	ZDATA_( CExecutorEvent )
		int nPlayer;
		CVec2 vTarget;
public:
	ZEND int operator&( IBinSaver &f ) { f.Add(1,( CExecutorEvent *)this); f.Add(2,&nPlayer); f.Add(3,&vTarget); return 0; }

	CExecutorEventSuperWeaponUse() : nPlayer( -1 ), vTarget( VNULL2 ) {}
	CExecutorEventSuperWeaponUse( const int _nPlayer, const CVec2 &_vTarget )
		: CExecutorEvent( SExecutorEventParam( EID_SUPER_WEAPON_USE, -1, -1 ) ), nPlayer( _nPlayer ), vTarget( _vTarget ) {}

	const int GetPlayer() const { return nPlayer; }
	const CVec2 &GetTarget() const { return vTarget; }
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
interface IExecutor :	public CAIObjectBase
{
	//  __it is optimization trick__
	// if IsExecutorValid() return GetNextTime. (see CExecutor)
	// itherwize return negative value.
	virtual int Segment() = 0;
	
	// return true if executer have to be called in current segment
	virtual bool NotifyEvent( const CExecutorEvent &event ) = 0;
	// if return false then this executor is to be deleted from any list
	virtual bool IsExecutorValid() const = 0;
	virtual int operator&( IBinSaver &saver ) 
	{
		return 0;
	}
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CExecutor : public IExecutor
{
	ZDATA
	EExecutorTypeID eTypeID;
	bool bActive;
	int nUniqueID;
	int nNextTime;													// when this executor will be called after segment
	int nID;
public:
	ZEND int operator&( IBinSaver &f ) { f.Add(2,&eTypeID); f.Add(3,&bActive); f.Add(4,&nUniqueID); f.Add(5,&nNextTime); f.Add(6,&nID); return 0; }
protected:
	void SetNextTime( const int _nNextTime ) { nNextTime = _nNextTime; }

	CExecutor( const EExecutorTypeID _eTypeID, const int _nNextTime );
	CExecutor();
	virtual ~CExecutor();
public:

	void IncID() 
	{ 
		++nID; 
	}
	const int GetID() const { return nID; }

	// return POSITIVE time, that must pass before next execution.
	// return NEGATIVE time if executor is to be deleted from active list
	// return NULL if executor to be registered as sleeping
	// time is in segment_duration
	int GetNextTime() const { return nNextTime; }

	EExecutorTypeID GetTypeID() const { return eTypeID; }
	bool IsActive() const { return bActive; }
	void SetActive( const bool _bActive ) { bActive = _bActive; }
	int GetInstanceID() const { return nUniqueID; }
	// executor may register himself on specific events
	virtual void RegisterOnEvents( IExecutorContainer *pContainer ) {}
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct SExecutorEventParamHash
{
	int operator()( const SExecutorEventParam &e ) const
	{ 
		return e.eEventID  + (e.nExecutorID << 8) + (e.nUnitID << 16); 
	}
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct SExecutorPtrHash
{
	int operator()( const CPtr<CExecutor> &p ) const
		{	return p->GetInstanceID(); }
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
interface IExecutorContainer : public CAIObjectBase
{
	// adds sleeping, have to be registered on event prior or after adding
	virtual void AddSleeping( CExecutor *pExecutor ) = 0;
	// add active, may be registered on event. 
	virtual void Add( CExecutor *pExecutor ) = 0;
	// 
	virtual void RegisterOnEvent( CExecutor *pExecutor, const SExecutorEventParam &ev ) = 0;
	virtual void RaiseEvent( const CExecutorEvent &event ) = 0;
	virtual void RaiseEvent( const SExecutorEventParam &param ) = 0;
	virtual void Segment() = 0;
	
	virtual int CreateID() = 0;
	virtual void ReturnID( const int id ) = 0;

};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
