/* Generated by Together */
#include "StdAfx.h"

#include "ManuverBuilder.h"
#include "ManuverInternal.h"
#include "PlanesFormation.h"
#include "DBAIConsts.h"

CManuverBuilder theManuverBuilder;
/////////////////////////////////////////////////////////////////////////////
CManuvers CManuverBuilder::manuvers;
vector<int> CManuverBuilder::suitableIndeces;
CManuverStateDesc CManuverBuilder::state;

/////////////////////////////////////////////////////////////////////////////
interface IManuver* CManuverBuilder::SGRoundAttackTarget::CreateManuver( class CPlanesFormation * pPos, const CVec3 &vEnemy, int nAttacker )
{
	const CPlanePreferences &pref = pPos->GetPreferencesB2();
	const CVec3 vPos( pPos->GetPosB2() );
	const float fMinPathLength = 2.0f * pref.GetR( pref.GetMaxSpeed() ) ;
	const CVec2 vDir( GetVectorByDirection( GetAngle( nAttacker ) ) );
	
	const float fDiveAngle = pref.GetDivingAngle() * 2.0f * PI / 65535;
	float fStartAttackDist = fMinPathLength;
	if ( fDiveAngle != 0.0f )
	{
		const float fBetta = ( PI - fDiveAngle ) / 2.0f;
		fStartAttackDist += ( vPos.z / tan( fDiveAngle ) );
	}
	CVec3 vAttackPos( CVec2( vEnemy.x, vEnemy.y ) + fStartAttackDist * vDir, pref.GetPatrolHeight() );

	CVec3 vDirection( vEnemy - vAttackPos );
	if ( fabs( vDirection ) < fMinPathLength ) // if path length is too small, then get longer path.
	{
		vAttackPos.x += vDir.x * fMinPathLength;
		vAttackPos.y += vDir.y * fMinPathLength;
	}	
	Normalize( &vDirection );
	CManuverPrepareGroundAttack * pManuver = new CManuverPrepareGroundAttack;
	pManuver->Init( pPos, vAttackPos, vDirection );
	return pManuver;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//	CManuverBuilder
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//#define STRING_ENUM_ADD(TypeConverter,eEnum) TypeConverter[#eEnum] = eEnum;
/////////////////////////////////////////////////////////////////////////////
void CManuverBuilder::Init( const NDb::SAIGameConsts *_pConsts )
{
	pConsts = _pConsts;
	
	const int nDescs = pConsts->planeManuvers.size();
	suitableIndeces.reserve( nDescs );
	for ( int i = 0; i < pConsts->planeManuvers.size(); ++i )
		manuvers[pConsts->planeManuvers[i]->eAttitude].push_back( i );
}
/////////////////////////////////////////////////////////////////////////////
const SManuverDescriptor *CManuverBuilder::Choose( const CManuverStateDesc &current, const CPlanePreferences &pref ) const
{
	CManuvers::const_iterator manuverPos = manuvers.find( current.GetAtt() );
	
	suitableIndeces.clear();
	
	if ( manuverPos != manuvers.end() )
	{
		const CManuverIndices &indices = manuverPos->second;
		
		for ( CManuverIndices::const_iterator it = indices.begin(); it != indices.end(); ++it )
		{
			const NDb::SManuverDescriptor *pDesc = pConsts->planeManuvers[*it];
			if ( pref.IsManuverAllowed( pDesc->eManuverID ) && current.CheckSuitable( pDesc ) )
				suitableIndeces.push_back( *it );
		}
	}
	if ( !suitableIndeces.empty() )
	{
		//CRAP{ TO DO
		// choose manuver by random or by preferences
		//CRAP}
		return pConsts->planeManuvers[*suitableIndeces.begin()];
	}

	return 0;
}
/////////////////////////////////////////////////////////////////////////////
interface IManuver * CManuverBuilder::CreateDefaultManuver( const enum EPlanesAttitude att, class CPlanesFormation *pPos, class CPlanesFormation *pEnemy )
{
	if ( EPA_RETREAT == att )
	{
		// horisontal manuver in random direction
		const CVec3 vSpeed( pPos->GetSpeedB2() );
		const float fSpeed( fabs( vSpeed ) );
		CVec3 vPerp ( -vSpeed.y, vSpeed.x, 0 );
		Normalize( &vPerp );
		vPerp *= ( NRandom::Random(0,1) == 1 ? -1 : 1 );

		const CVec3 vPoint( pPos->GetPosB2() + 2.1f * vPerp * pPos->GetPreferencesB2().GetR( fSpeed ) );
		return CreatePointManuver( pPos, vPoint, false );
	}
	else
	{
		// aim to predicted point
		const CVec3 vAimPoint( CalcAttackerPoint( pPos, pEnemy ) );
		return CreatePointManuver( pPos, vAimPoint, true );
	}
}
/////////////////////////////////////////////////////////////////////////////
CVec3 CManuverBuilder::CalcAttackerPoint( class CPlanesFormation *pAttacker, class CPlanesFormation *pEnemy )
{
	const CVec3 vPoint( CManuver::CalcPredictedPoint( pAttacker, pEnemy ) );
	CVec3 vSpeed( CManuver::CalcPredictedSpeed( pAttacker, pEnemy ) );
	Normalize( &vSpeed );
	
	int nAttackerIndex = RegisterAsAttacker( pAttacker, pEnemy );
	
	const CVec3 vOffset( attacks[pEnemy->GetFormationID()][nAttackerIndex].second );
	const CVec2 vSpeed2( vSpeed.x, vSpeed.y );
	CVec2 vOffset2( -vOffset.y, vOffset.x );
	vOffset2 = vSpeed2 ^ vOffset2;
	return CVec3( vOffset2.x + vPoint.x, vOffset2.y + vPoint.y, vOffset.z + vPoint.z );
}
/////////////////////////////////////////////////////////////////////////////
CVec3 CalcOffsetByIndex( int nIndex )
{
	return CVec3( -200 - 50 * nIndex, nIndex * 50 * ( nIndex % 3 - 1 ), nIndex * 50 * ( ( (nIndex + 1 ) % 3 - 1 ) ) );
}
/////////////////////////////////////////////////////////////////////////////
int CManuverBuilder::RegisterAsAttacker( class CPlanesFormation *pAttacker, class CPlanesFormation *pEnemy )
{
	CAviaAttacks::iterator it = attacks.find( pEnemy->GetFormationID() );
	if ( it != attacks.end() )
	{
		for ( int i = 0; i < it->second.size(); ++i )
		{
			if ( it->second[i].first == pAttacker->GetFormationID() )
				return i;
		}
		for ( int i = 0; i < it->second.size(); ++i )
		{
			if ( !CPlanesFormation::IsFormaionExists( it->second[i].first ) )
			{
				it->second[i].first = pAttacker->GetFormationID();
				return i;
			}
		}
	}
	int nIndex = attacks[pEnemy->GetFormationID()].size();
	attacks[pEnemy->GetFormationID()].push_back( pair<int,CVec3>( pAttacker->GetFormationID(), CalcOffsetByIndex( attacks[pEnemy->GetFormationID()].size() ) ) );
	return nIndex;
}
/////////////////////////////////////////////////////////////////////////////
interface IManuver* CManuverBuilder::CreatePointManuver ( class CPlanesFormation *pPos, const CVec3 &vPoint, const bool bToHorisontal )
{
	const float fDist = fabs( pPos->GetPosB2() - vPoint );
	const CPlanePreferences &pref = pPos->GetPreferencesB2();
	const float fR ( pref.GetR( fabs( pPos->GetSpeedB2() ) ) );

	if ( bToHorisontal && fDist > fR * 2.5f )
	{
		CManuverToHorisontal *pManuver = new CManuverToHorisontal;
		pManuver->Init( pPos, vPoint );
		return pManuver;
	}
	else
	{
		CManuverGeneric *pManuver = new CManuverGeneric;
		pManuver->Init( pPos, vPoint );
		return pManuver;
	}
}
/////////////////////////////////////////////////////////////////////////////
EPlanesAttitude CManuverBuilder::GetAttitude( class CPlanesFormation *pPlane, class CPlanesFormation *pEnemy ) const
{ 
	if ( pPlane->IsBeingAttackedB2()  )
		return EPA_RETREAT;
	return EPA_ATTACK;
}
/////////////////////////////////////////////////////////////////////////////
interface IManuver* CManuverBuilder::CreateManuver ( class CPlanesFormation *pPos, const CVec3 &vPos, int nTargetUniqueID )
{
	//return CreateDefaultManuver( att, pPos, pEnemy );
	// create maneuver to attack ground unit
	const int nFormationID = pPos->GetFormationID();
	
	SGRoundAttackTarget &target = groundAttacks[nTargetUniqueID];

	while( true )
	{
		for ( int i = 0; i < target.nMaxAttakers; ++i )
			if ( target.attackers[i] == nFormationID )
				return target.CreateManuver( pPos, vPos, i );

		for ( int i = 0; i < target.nMaxAttakers; ++i )
		{
			if ( !CPlanesFormation::IsFormaionExists( target.attackers[i] ) )
			{
				target.attackers[i] = nFormationID;
				return target.CreateManuver( pPos, vPos, i );
			}
		}
		target.IncreaseMaxAttackers();
	}

	return 0;
}
/////////////////////////////////////////////////////////////////////////////
interface IManuver* CManuverBuilder::CreateManuver ( class CPlanesFormation *pPos, class CPlanesFormation *pEnemy )
{
	EPlanesAttitude att = GetAttitude( pPos, pEnemy );
	state.Init( att, pPos, pEnemy );
	const CPlanePreferences &pref = pPos->GetPreferencesB2();

	const SManuverDescriptor *pDesc = Choose( state, pref );
	/*if ( pDesc )
	{
		// create manuver according to descriptor and return
		IManuver * pManuver = MakeObject<IManuver>( pDesc->GetManuverID() );
		pManuver->Init( pDesc->GetDestination(), pPos, pEnemy );
		return pManuver;
	}
	else*/
		return CreateDefaultManuver( att, pPos, pEnemy );
}
