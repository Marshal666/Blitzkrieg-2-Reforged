/* Generated by Together */

#ifndef IMANUVER_H
#define IMANUVER_H

#pragma once

namespace NDb
{
	enum EManuverDestination;
}
// IManuver will return member data in this struct
struct SFormationMemberInfo
{
ZDATA
	CVec3 vWorldPosition;
	CVec3 vSpeed;
	CVec3 vNormal;

	NTimer::STime lastMoveTime;
	public: ZEND int operator&( IBinSaver &f ) { f.Add(2,&vWorldPosition); f.Add(3,&vSpeed); f.Add(4,&vNormal); f.Add(5,&lastMoveTime); return 0; }
public:
	SFormationMemberInfo() 
		: lastMoveTime( NTimer::STime(-1) ), vWorldPosition( VNULL3 ), vSpeed( VNULL3 ), vNormal( VNULL3 )
	{ 
	}
};

extern float g;
/**
 * у кажддого маневра есть ID.
 * @interface
 */
interface IManuver : public CAIObjectBase
{
	// world position
	virtual CVec3 GetPos() const = 0;
	// plane speed 
	virtual CVec3 GetSpeed() const = 0;
	// plane's top direction
	virtual CVec3 GetNormale() const = 0;
	// preferred top direction
	virtual CVec3 GetTopDirection() const = 0;

	// advance plane according it's speed 
	// return true if manuver is finished.
	virtual bool Advance( const NTimer::STime timeDiff ) = 0;

	// if manuver is used current segment -then it is touched, onterwize not
	//CRAP{ TO DO USED TRACKING
	virtual void Used( const bool bUsed ) {}
	virtual bool IsUsed() { return true; }
	//CARP}
	// PREDICTION
	// return approximate point, where plane will be in fT time.
	virtual CVec3 GetProspectivePoint( const NTimer::STime nTime ) const = 0;
	virtual CVec3 GetProspectiveSpeed( NTimer::STime nTime ) const = 0;
	
	// init manuver to specific point, or destination (COMBAT ONLY)
	virtual void Init( const NDb::EManuverDestination dest, class CPlanesFormation *pPlane, interface IPlane *pEnemy = 0 ) { NI_ASSERT(false,"WRONG CALL");}
	virtual void GetManuverParams( struct SPrevPathParams *pParams ) const { NI_ASSERT( false, "wron call" ); }
	virtual void SetPlane( class CPlanesFormation *pPlane ) = 0;

	virtual bool IsToHorisontal() const = 0;
	//CRAP{ FOR TEST
	virtual const CVec3 GetEndPoint() const = 0;
	//CRAP}
};
#endif //IMANUVER_H
