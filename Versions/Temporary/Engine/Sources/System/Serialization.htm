<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Сериализация</title>
		<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
	</head>
	<body>
		<p>
			Мы модифицировали систему subj`a в b2 так, что теперь можно использовать 
			макросы <STRONG>ZDATA/ZEND</STRONG> столь популярные в проекте a5. Эти макросы 
			позволяют заметно сократить усилия, необходимые для поддержания subj`a в 
			рабочем состоянии. Идея заключается в том, что можно генерировать оператор 
			сериализации автоматически если добавить в исходный код программы маркеры по 
			которым можно будет найти место определения переменных класса. Для обозначения 
			начала такого места используется макрос <STRONG>ZDATA</STRONG> , для 
			обозначения конца <STRONG>ZEND</STRONG>. Способ их применения рассмотрим на 
			примере:
		</p>
		<PRE> class CSomething<br>
  {<br>
  ZDATA <br>
  int a , b ; <br>
  CPtr &lt; CAasdf &gt; pBlah ; <br>
  public : // public нужен потому что оператор сериализации должен быть public для структур и базовых классов, иначе IBinSaver не будет иметь к нему доступа и будет ошибка компиляции <br>
  ZEND &lt; - в этом месте в одну строчку будет сгенерирован оператор сериализации <br>
  }; </PRE>
		<p>
			Если редактируя такой файл запустить макрос serialize из 
			N:\Dev\Soft\Soft\msvcMacros\Serialize7\, то он автоматически на месте стрелки 
			сгенерит оператор сериализации.
		</p>
		<p>
			Функции не должны находится на промежутке от <STRONG>ZDATA</STRONG> до <STRONG>ZEND</STRONG>
		</p>
		<p>
			Помимо <STRONG>ZDATA</STRONG> &amp; <STRONG>ZEND</STRONG> есть макрос <STRONG>ZPARENT</STRONG>( 
			parentClassName ) – он позволяет указывать, что данные находящиеся в предке 
			parentClassName должны тоже сериализоваться. Есть также макрос <STRONG>ZDATA _</STRONG>( 
			parentClassName ) – это сокращение для часто встречающейся последовательности <STRONG>
				ZDATA</STRONG> , <STRONG>ZPARENT</STRONG> ( parentClassName ). Еще есть 
			макрос <STRONG>ZSKIP</STRONG>, он нужен для поддержки старых сейвов. Поддержка 
			старых сейвов основана на том, что <EM>chunkID</EM> одних и тех же данных 
			одинаковы в разных версиях приложения. Так как <EM>chunkID</EM> при создании 
			оператора сериализации генерируются макросом последовательно, то при удалении 
			поля у нас изменятся номера chunk`ов всех последующих членов класса и, 
			соответственно, считывание старого сейва станет неправильным. Чтобы этого не 
			происходило на место удаленного члена класса нужно поставить <STRONG>ZSKIP</STRONG>
			(если требуется поддерживать старые сейвы), тогда макрос прибавит единичку к 
			номеру <EM>chunkID</EM> и все будет в порядке. По этой же причине новые члены 
			класса необходимо добавлять в конец.
		</p>
		<p>
			Если какую-то структуру можно сериализовать как данные (в ней нет ни одного 
			указателя и в нее не будут добавляться/ удаляться поля), то оператор 
			сериализации можно для нее не делать (то есть не писать <STRONG>ZDATA / ZEND</STRONG>
			в этой структуре). В этом случае такая структура будет записываться в сейв в 
			виде бинарных данных.
		</p>
		<p>
			Неудобно иметь статические member`ы классов, так как subj заточен на 
			сериализацию объектов в куче, а статические member`ы требуют особой обработки. 
			Даже если их сериализовать обычным способом, то если таких объектов будет 
			несколько, то мы получим многократную запись одних и тех же данных, а если 
			такого объекта на куче нет, то статические данные такого объекта и вовсе 
			записаны не будут. Поэтому по возможности рекомендуется обходится без 
			статических member`ов.
		</p>
		<P>К сожалению присутствует небольшая несовместимость с предыдущим subj`ем b2 
			которая заключается в том, что новый subj при отсутствии оператора сериализации 
			у структуры или класса будет сериализовать такую структуру/класс как данные, в 
			том время как subj b2 звал в таком случае оператор сериализации предка при его 
			наличии. Вроде бы мест в b2, которые полагаются на это поведение больше нет.</P>
		<p>
			Правильный способ проверки работоспособности subj`a включает в себя save и как 
			минимум 2 кратный load (при однократном лоаде некоторые баги могут себя не 
			проявить). Также полезно записать в одной конфигурации (например, release ), а 
			считать в другой. Если заработает вы можете быть уверены, что не записали 
			указатель на таблицу виртуальных функций класса как данные (это можно сделать 
			достаточно просто, например, если в базовом классе нет оператора сериализации, 
			а вы указали его в <STRONG>ZPARENT</STRONG> ).
		</p>
		<p>
			Наиболее часто встречающиеся ошибки в subj`е: забыл перегенерить оператор 
			сериализации (полезно забиндить макрос на какую-нибудь кнопку, например, alt_q 
			), переменная, которая должна сериализоваться не находится между <STRONG>ZDATA / 
				ZEND</STRONG> , указан предок для сериализации, а у него не определен 
			оператор сериализации (в этом случае он запишется как данные, что в большинстве 
			случаев не совсем то, что вы хотели :)
		</p>
		<H2>Что нужно делать, чтобы save’ы протухали как можно реже</H2>
		<P class="MsoNormal">Если вы изменили каки-то данные (тип, размер, и т.д.), которые 
			подлежат save’у, то необходимо save’ить их под другим <I style="mso-bidi-font-style: normal">
				chunkID</I>. <A style="mso-comment-reference: YB_1; mso-comment-date: 20040531T1831">
				<SPAN style="COLOR: red">Если вы пишете оператор сериализации вручную, то необходимо 
изменить </SPAN></A><I style="mso-bidi-font-style: normal"><SPAN lang="EN-US" style="COLOR: red; mso-ansi-language: EN-US">chunkID</SPAN></I><SPAN style="COLOR: red"> в соответствующей записи</SPAN>. 
			Если вы пользуетесь автоматической системой <B style="mso-bidi-font-weight: normal">
				ZDATA</B>—<B style="mso-bidi-font-weight: normal">ZEND</B>, то необходимо 
			перенести эту переменную в самый конец блока, а на её месте поставить <B style="mso-bidi-font-weight: normal">
				ZSKIP</B> (это сохранит порядок нумерации для остальных полей в блоке).
		</P>
		<P class="MsoNormal">После load’а в этом поле будет либо 0 (для объектов, у которых 
			нет оператора сериализации), либо то, что создано конструктором или было до 
			load’а (для объектов, у которых есть оператор сериализации). Если вас не 
			устраивают такие данные, то необходимо позаботиться об их корректном 
			заполнении. <A style="mso-comment-reference: YB_2; mso-comment-date: 20040531T1832">
				<SPAN style="COLOR: red">Для этого, если вы пишете оператор сериализации сами, 
необходимо в конце проверить на </SPAN></A><SPAN style="mso-comment-continuation: 2"><I style="mso-bidi-font-style: normal"><SPAN lang="EN-US" style="COLOR: red; mso-ansi-language: EN-US">saver</SPAN>.</I></SPAN><SPAN style="mso-comment-continuation: 2"><I style="mso-bidi-font-style: normal"><SPAN lang="EN-US" style="COLOR: red; mso-ansi-language: EN-US">IsReading</SPAN>()</I><SPAN style="COLOR: red"> и написать какую-то 
свою инициализацию</SPAN>&nbsp;
			</SPAN>&nbsp; . Если же вы пользуетесь автоматической системой <B style="mso-bidi-font-weight: normal">
				ZDATA</B>—<B style="mso-bidi-font-weight: normal">ZEND</B>, то перед <B style="mso-bidi-font-weight: normal">
				ZEND</B>необходимо написать <B style="mso-bidi-font-weight: normal">ZONSERIALIZE</B>– 
			это заставит систему сгенерить в конце оператора сериализации вызов функции <I style="mso-bidi-font-style: normal">
				OnSerialize</I> – и определить в этом классе/структуре функцию <I style="mso-bidi-font-style: normal">
				void</I><I style="mso-bidi-font-style: normal">OnSerialize( </I><I style="mso-bidi-font-style: normal">
				IBinSaver &amp;</I><I style="mso-bidi-font-style: normal">saver )</I>, в 
			которой написать соответствующую инициализацию по тем же правилам.</P>
		<P class="MsoNormal">Если вам необходимо какой-то старый класс заменить на два или 
			более новых, то в этом случае сохранить save’ы, к сожалению, лёгким образом 
			невозможно. Можно читать старый объект и заменять его на новый(е), но так мы 
			никогда не делали и геморрой это страшный. Так следует делать только если 
			гибель save’ов <B style="mso-bidi-font-weight: normal"><U>недопустима</U></B> вообще. 
			Если гибель save’ов допустима, то в этом случае save’ы умрут, как это не 
			печально. Перед тем, как убить save’ы, необходимо за несколько дней 
			предупредить все заинтересованные проекты об этом. При убиении save’ов полезно 
			вычистить все вещи, которые делались для сохранения предыдущих версий save’ов, 
			т.к. это облегчит код и избавит его от совершенно неиспользуемых и даже уже 
			вредных вещей. Всем новым объектам необходимо присвоить новые <I style="mso-bidi-font-style: normal">
				typeIDs</I> –использование <I style="mso-bidi-font-style: normal">typeID</I>от 
			умершего класса для одного из новых допустимо только в том случае, если этот 
			новый объект имеет оператор сериализации абсолютно идентичный старому классу и 
			мы пытаемся таким образом сохранить работоспособность старого save’а – в любом 
			другом случае необходимо присвоить новые <I style="mso-bidi-font-style: normal">typeIDs</I>.</P>
	</body>
</html>
