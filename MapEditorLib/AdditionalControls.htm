<HTML>
	<HEAD>
		<TITLE></TITLE>
		<META content="Microsoft Visual Studio .NET 7.1" name="GENERATOR">
	</HEAD>
	<BODY>
		<H3>Создание дополнительных объектов в редакторах.</H3>
		<P>Объекты в редакторах подразделяются на три типа: docking windows toolbars и 
			menu. В зависимости от типа активного редактора мы показываем разный набор 
			дополнительных объектов. Идея состоит в том, чтобы создавать все объекты на 
			этапе старта программы. Изначально все дополнительные объекты скрыты. При 
			старте какого-нибудь редактора появляются объекты, относящиеся к этому 
			редактору, по завершении редактора эти объекты снова скрываются. С меню 
			ситуация немного сложнее так как одновременно можно показать только одно меню, 
			соответственно при старте редактора мы скрываем меню по умолчанию и показываем 
			меню относящееся к данному редактору. При закрытии редактора мы восстанавливаем 
			меню по умолчанию.</P>
		<P>Чтобы редакторам вызывались методы CreateControls(), PostCreateControls(), 
			PreDestroyControls() и DestroyControls() необходимо в методе 
			ModuleCreate()создать эти редакторы следующим образом:</P>
		<PRE><FONT color=#990033>CMyDLLModule::ModuleCreate()
{
	…
	Singleton&lt;IEditorContainer&gt;()-&gt;Create( "MyEditorType0" ); // тип редактора
	Singleton&lt;IEditorContainer&gt;()-&gt;Create( "MyEditorType1" ); // …
	Singleton&lt;IEditorContainer&gt;()-&gt;Create( "MyEditorType2" ); // …
	…
}</FONT></PRE>
		<P>Давайте подробнее остановимся на методах работы с каждым объектом. Docking 
			windows может быть несколько, все они помечаются определенным ID, для этих ID 
			существует выделенный набор 300 – 399 ID, начальный ID для удобства существует 
			в виде макроса: IDC_DOCKING_WINDOW_0, определен он в файле 
			..\MapEditorLib\ResourceDefines.h. Для каждого docking window, необходимо в 
			редакторе завести две переменные.</P>
		<PRE>SECControlBar *pwndMyDockingWindowControlBar;	// это описатель control bar
CMyDockingWindow wndMyDockingWindow;			// это непосредственно окно</PRE>
		<P>Можно также создать новый тип данных хранящий настроечную информацию о нашем 
			редакторе:</P>
		<PRE><FONT color=#990033>struct SMyEditorSettings
{
	bool bShowMyDockingWindow;
	…
	SMyEditorSettings () : bShowMyDockingWindow( true ), … {}
	int operator&amp;( IXmlSaver &amp;xs )
	{
		xs.Add( "ShowMyDockingWindow", &amp;bShowMyDockingWindow );
		…
		return 0;
	}
};
SMyEditorSettings myEditorSettings;</FONT></PRE>
		<P>Для считывания с сохранения настроек редактора предусмотрено два метода.</P>
		<PRE>cчитывание:

<FONT color=#990033>SUserData *pUserData = Singleton&lt;IUserDataContainer&gt;()-&gt;Get();
pUserData-&gt;SerializeSettings( myEditorSettings, “MyEditor”, SUserData::EDITOR_SETTINGS, SUserData::ST_LOAD );</FONT>

сохранение:

<FONT color=#990033>SUserData *pUserData = Singleton&lt;IUserDataContainer&gt;()-&gt;Get();
pUserData-&gt;SerializeSettings( myEditorSettings, “MyEditor”, SUserData::EDITOR_SETTINGS, SUserData::ST_SAVE );</FONT></PRE>
		<P>Далее следует выделить идентификатор из указанного выше набора: 
			ID_MY_DOCKING_WINDOW. Заведите строку в ресурсах для именования docking window, 
			пусть строку идентифицирует ID: IDS_MY_DOCKING_WINDOW_NAME. Теперь необходимо 
			вставить код создания окна в метод IEditor::CreateControls(). Этот метод 
			вызывается до считывания расположения и размеров объектов из registry 
			средствами Stingray. Метод CreateControlBar выделяет память внутри себя, 
			указатель который он возвращает, следует удалять самостоятельно.</P>
		<PRE><FONT color=#990033>CMyEditor::CreateControls()
{
	IMainFrame *pMainFrame = Singleton&lt;IMainFrameContainer&gt;()-&gt;Get();
	…
	CString strName;
	strName.LoadString( IDS_MY_DOCKING_WINDOW_NAME );
	UINT nID = ID_MY_DOCKING_WINDOW;
	if ( pwndMyWindowControlBar = pMainFrame-&gt;CreateControlBar( &amp;nID, strName, CBRS_ALIGN_ANY, AFX_IDW_DOCKBAR_RIGHT, 0.5f, 200 ) )
	{
		if ( wndMyDockingWindow.Create(pwndMyWindowControlBar, … )
		{ 
			…
		}
	}
	…
}</FONT></PRE>
		<P>В методе IEditor::PostCreateControls() необходимо вставить скрытие нового 
			docking window, это необходимо для того чтобы объекты редакторов не были видны 
			пока редактор не активен. Метод PostCreateControls() вызывается после 
			восстановления размеров и позиций объектов программы средствами Stingray. 
			Поэтому если какой либо объект случайно оказался не скрытым, мы его скроем.</P>
		<PRE><FONT color=#990033>void CMyEditor::PostCreateControls()
{
	SECWorkbook *pWorkbook = Singleton&lt;IMainFrameContainer&gt;()-&gt;GetSECWorkbook();
	…
	if ( pwndMyDockingWindowControlBar!= 0 )
	{
		pWorkbook-&gt;ShowControlBar(pwndMyDockingWindowControlBar, false, true );
	}
	…
}</FONT></PRE>
		<P>В метод IEditor::PreDestroyControls() тоже необходимо вставить скрытие новых 
			docking window. Метод PreDestroyControls() вызывается перед сохранением 
			объектов программы средстави Stringray. Следовательно нам нужно чтобы объекты 
			редакторов сохранялись в скрытом виде, при этом их размеры и положения будут 
			сохранены.</P>
		<PRE><FONT color=#990033>void CMyEditor::PreDestroyControls()
{
	SECWorkbook *pWorkbook = Singleton&lt;IMainFrameContainer&gt;()-&gt;GetSECWorkbook();
	…
	if ( pwndMyDockingWindowControlBar!= 0 )
	{
		pWorkbook-&gt;ShowControlBar( pwndMyDockingWindowControlBar, false, true );
	}
	…
}</FONT></PRE>
		<P>Разрушать новые docking windows следует в методе DestroyControls(). Их 
			расположение и размеры уже сохранены средствами Stingray. Новые docking window 
			необходимо удалять из памяти с помощью delete.</P>
		<PRE><FONT color=#990033>void CMyEditor::DestroyControls()
{
	…
	if ( pwndMyDockingWindowControlBar!= 0 )
	{
		if ( ::IsWindow( pwndMyDockingWindowControlBar-&gt;m_hWnd ) )
		{
			pwndMyDockingWindowControlBar-&gt;DestroyWindow();
		}
		delete pwndMyDockingWindowControlBar;
		pwndMyDockingWindowControlBar = 0;
	}
	wndMyDockingWindow.DestroyWindow();
	…
}</FONT></PRE>
		<P>
		При старте редактора docking window следует показать. Его позиция и размер 
		соответствует тому, что было при закрытии редактора в прошлый раз. Единственно, 
		что мы должны сохранять и считывать самостоятельно – факт видимости объекта.
		<P><PRE><FONT color=#990033>void CMyEditor::Create()
{ 
	SECWorkbook *pWorkbook = Singleton&lt;IMainFrameContainer&gt;()-&gt;GetSECWorkbook();
	…
	SUserData *pUserData = Singleton&lt;IUserDataContainer&gt;()-&gt;Get();
	pUserData-&gt;SerializeSettings( myEditorSettings, “MyEditor”, SUserData::EDITOR_SETTINGS, SUserData::ST_LOAD );
	…
	if ( pwndMyDockingWindowControlBar != 0 )
	{ 
		pWorkbook-&gt;ShowControlBar( pwndMyDockingWindowControlBar, myEditorSettings.bShowMyDockingWindow, true ); 
	}
	…
}</FONT></PRE>
		<P>При закрытии редактора необходимо сохранить факт видимости docking window и 
			скрыть его.</P>
		<PRE><FONT color=#990033>void CMyEditor::Destroy()
{
	if ( Singleton&lt;IMainFrameContainer&gt;() &amp;&amp;
	     Singleton&lt;IMainFrameContainer&gt;()-&gt;Get() &amp;&amp;
	     Singleton&lt;IMainFrameContainer&gt;()-&gt;GetSECWorkbook() )
	{
		SECWorkbook *pWorkbook = Singleton&lt;IMainFrameContainer&gt;()-&gt;GetSECWorkbook();
		…
		if ( pwndMyDockingWindowControlBar != 0 )
		{
			myEditorSettings.bShowMyDockingWindow=pwndMyDockingWindowControlBar-&gt;IsVisible();
			pWorkbook-&gt;ShowControlBar( pwndMyDockingWindowControlBar, false, true );
		}
		…
		SUserData *pUserData= Singleton&lt;IMainFrameContainer&gt;()-&gt;Get(); 
		pUserData-&gt;SerializeSettings( myEditorSettings, “MyEditor”, SUserData::EDITOR_SETTINGS, SUserData::ST_SAVE );
	}
}</FONT></PRE>
		<P>Docking window объекты также можно создавать без привязки к редакторам, для 
			этого надо использовать похожие методы из класса IEditorModule. Так как эти 
			объекты глобальны то нет никакой необходимости специальным образом запоминать 
			факт из скрытости, достаточно просто создать docking window.</P>
		<PRE><FONT color=#990033>void ModuleCreateControls();	// создание дополнительных глобальных объектов
void ModuleDestroyControls();	// удаление дополнительных глобальных объектов</FONT></PRE>
		<P>Toolbar объекты создаются в каждом редакторе отдельно. В toolbar могут 
			содержаться специальные элементы нижеперечисленных типов. Подробнее о каждом 
			типе можно почитать в Stingray Help.</P>
		<PRE><FONT color=#990033>STD_BUTTON	// кнопка со стилем ( checkbox например )
STD_MENU_BUTTON	// кнопка меню (как в меню) TEXT_BUTTON // кнопка текст (как в меню)
TEXT_BUTTON_EX	// кнопка текст с наворотами TWOPART_BUTTON // двойная кнопка (как Undo c уровнями)
COMBO_BUTTON	// combobox</FONT></PRE>
		<P>Для создания toolbar нам необходимо определить переменную в которой мы будем 
			хранить ID нашего toolbar. ID выдается автоматически, начиная с AFX_IDW_TOOLBAR 
			+ 9.</P>
		<PRE><FONT color=#990033>UINT nMyToolbarID;</FONT></PRE>
		<P>Заведите строку в ресурсах для именования toolbar, пусть строку идентифицирует 
			ID: IDS_MY_TOOLBAR_NAME. С помощью VC 7.1 resource editor создайте toolbar 
			resource и присвойте ему ID из набора: 10000…10199. Пусть это будет 
			IDT_MY_TOOLBAR. Теперь необходимо определить список кнопок в новом toolbar, это 
			делается с помощью статического глобального массива UINT:</P>
		<PRE>MyEditor.h:
		
<FONT color=#990033>#define MY_TOOLBAR_ELEMENTS_COUNT ##
EXTERNVAR const UINT MY_TOOLBAR_ELEMENTS_ID[TOOLBAR[MY_TOOLBAR_ELEMENTS_COUNT];</FONT>

MyEditor.cpp:

<FONT color=#990033>const UINT MY_TOOLBAR_ELEMENTS_ID[TOOLBAR MY_TOOLBAR_ELEMENTS_COUNT] =
{
	ID_MY_FIRST_COMMAND,
	…
	ID_SEPARATOR,
	ID_MY_TOPART_0,
	ID_MY_TOPART_1,
	…
	ID_MY_LAST_COMMAND,
};</FONT></PRE>
		<P>Теперь необходимо задать стили специальным кнопкам. В нашем случае это twopart 
			button состоящая из двух кнопок c ID: ID_MY_TOPART_0 и ID_MY_TOPART_1. Для 
			этого находимо файл ToolBarButtonsMapSpecific.h (он находятся в главной проекте 
			вашей DLL) и записываем туда следующую строчку. Кроме такого рода строчек в 
			этот файл помещать ничего не надо, иначе программа не будет компилироваться.</P>
		<PRE><FONT color=#990033>TWOPART_BUTTON( ID_MY_TOPART_0, ID_MY_TOPART_1, 0, ID_MY_TOPART_1 )</FONT></PRE>
		<P>Все подготовительные шаги сделаны, теперь приступим к созданию toolbar. Пусть 
			handle для нашей DLL будет theMyDLLInstance, он описан в гловном проекте вашей 
			DLL. В методе CreateControls вызываем следующее:</P>
		<PRE><FONT color=#990033>CMyEditor::CreateControls()
{
	IMainFrame *pMainFrame = Singleton&lt;IMainFrameContainer&gt;()-&gt;Get();
	…
	AfxSetResourceHandle( theMyDLLInstance );
	CString strName;
	strName.LoadString( IDS_MY_TOOLBAR_NAME );
	pMainFrame-&gt;AddToolBarResource( IDT_MY_TOOLBAR, IDT_MY_TOOLBAR );
	pMainFrame-&gt;CreateToolBar( &amp;nMyToolbarID, strName, MY_TOOLBAR_ELEMENTS_COUNT, UINT MY_TOOLBAR_ELEMENTS_ID, CBRS_ALIGN_ANY, AFX_IDW_DOCKBAR_TOP, true, false );
	AfxSetResourceHandle( AfxGetInstanceHandle() );
	…
}</FONT></PRE>
		<P>Далее в методе PostCreateControls() новый toolbar следует скрыть:</P>
		<PRE><FONT color=#990033>void CMyEditor::PostCreateControls()
{
	IMainFrame *pMainFrame = Singleton&lt;IMainFrameContainer&gt;()-&gt;Get();
	SECWorkbook *pWorkbook = Singleton&lt;IMainFrameContainer&gt;()-&gt;GetSECWorkbook();
	…
	if ( SECCustomToolBar *pMyToolbar = pMainFrame-&gt;GetToolBar( nMyToolbarID ) )
	{
		pWorkbook-&gt;ShowControlBar( pMyToolbar, false, true );
	}
	…
}</FONT></PRE>
		<P>Разрушение toolbar заключается в скрытии его в методе PreDestroyControls(). 
			Программа сама разрушает дополнительные toolbars.</P>
		<PRE><FONT color=#990033>void CMyEditor::PreDestroyControls()
{
	SECWorkbook *pWorkbook = Singleton&lt;IMainFrameContainer&gt;()-&gt;GetSECWorkbook();
	…
	if ( SECCustomToolBar *pMyToolbar = pMainFrame-&gt;GetToolBar( nMyToolbarID ) )
	{
		pWorkbook-&gt;ShowControlBar( pMyToolbar, false, true );
	}
	…
}</FONT></PRE>
		<P>При старте редактора, аналогично с docking window, считываем флаг скрытости 
			toolbar и показываем toolbar. Пусть в нашей настроечной структуре данных 
			SMyEditorSettings поле bShowMyToolbar отвечает за скрытость проекта.</P>
		<PRE><FONT color=#990033>void CMyEditor::Create()
{
	IMainFrame *pMainFrame = Singleton&lt;IMainFrameContainer&gt;()-&gt;Get();
	SECWorkbook *pWorkbook = Singleton&lt;IMainFrameContainer&gt;()-&gt;GetSECWorkbook();
	…
	SUserData *pUserData = Singleton&lt;IMainFrameContainer&gt;()-&gt;Get();
	pUserData-&gt;SerializeSettings( myEditorSettings, “MyEditor”, SUserData::EDITOR_SETTINGS, SUserData::ST_LOAD );
	…
	if ( SECCustomToolBar *pMyToolbar = pMainFrame-&gt;GetToolBar( nMyToolbarID ) )
	{
		pWorkbook-&gt;ShowControlBar( pMyToolbar, myEditorSettings. bShowMyToolbar, true );
	}
	…
}</FONT></PRE>
		<P>В методе Destroy() убеждаемся, что новый toolbar скрыт и запоминаем его флаг 
			скрытости.</P>
		<PRE><FONT color=#990033>void CMyEditor::Destroy()
{
	if ( Singleton&lt;IMainFrameContainer&gt;() &amp;&amp;
		Singleton&lt;IMainFrameContainer&gt;()-&gt;Get() &amp;&amp;
		Singleton&lt;IMainFrameContainer&gt;()-&gt;GetSECWorkbook() )
	{
		IMainFrame *pMainFrame = Singleton &lt;IMainFrameContainer&gt;()-&gt;Get();
		SECWorkbook *pWorkbook = Singleton&lt;IMainFrameContainer&gt;()-&gt;GetSECWorkbook();
		…
		if ( SECCustomToolBar *pMyToolbar = pMainFrame-&gt;GetToolBar( nMyToolbarID ) )
		{
			myEditorSettings.bShowMyToolbar = pMyToolbar-&gt;IsVisible();
			pWorkbook-&gt;ShowControlBar( pMyToolbar, false, true );
		}
		…
		SUserData *pUserData = Singleton&lt;IMainFrameContainer&gt;()-&gt;Get();
		pUserData-&gt;SerializeSettings( myEditorSettings, “MyEditor”, SUserData::EDITOR_SETTINGS, SUserData::ST_SAVE );
	}
}</FONT></PRE>
		<P>Toolbar объекты также можно создавать без привязки к редакторам, для этого надо 
			использовать похожие методы из класса IEditorModule. Так как эти объекты 
			глобальны то нет никакой необходимости специальным образом запоминать факт из 
			скрытости, достаточно просто создать toolbar.</P>
		<PRE><FONT color=#990033>void ModuleCreateControls(); // создание дополнительных глобальных объектов
void ModuleDestroyControls(); //удаление дополнительных глобальных объектов</FONT></PRE>
		<P>Если вы хотите чтобы ваши новые toolbars показывались в диалоге настройки 
			toolbars необходимо проделать следующие операции. В методе 
			GetCursomToolBarsInfo вашего приложения необходимо перечислить те tollbars 
			которые участвуют в настройках.</P>
		<PRE><FONT color=#990033>void CMyEditorAppSpecific::GetCursomToolBarsInfo( CCursomToolBarInfoList *pCursomToolBarInfoList ) const
{
	AfxSetResourceHandle( theMyDLLInstance );
	CCursomToolBarInfoList::iterator itCursomToolBarInfo = pCursomToolBarInfoList-&gt;insert( pCursomToolBarInfoList-&gt;end(), SCursomToolBarInfo() );
	itCursomToolBarInfo-&gt;strName.LoadString( IDS_MY_TOOLBAR_NAME );
	itCursomToolBarInfo-&gt;nCount = MY_TOOLBAR_ELEMENTS_COUNT;
	itCursomToolBarInfo-&gt;pButtons = static_cast&lt;CONST UINT*&gt;( MY_TOOLBAR_ELEMENTS_ID );
	…
	AfxSetResourceHandle( AfxGetInstanceHandle() );
}</FONT></PRE>
		<P>Для каждого редактора можно указать свое меню, кроме того необходимо 
			самостоятельно создавать для каждой программы меню по умолчанию. Все меню для 
			всех редакторов и основное меню создаются в одном месте. При запуске 
			конкретного редактора мы включаем его меню, при выходе из редактора мы 
			восстанавливаем меню по умолчанию. Создайте в ресурсах вашей DLL основное меню 
			и меню для каждого редактора, где оно отличается от основного. Набор ID для 
			меню следующий: 10600 – 10799. Пусть основное меню расположено по ID: IDM_MAIN_MENU,
			а меню для нашего редактора IDM_MY_EDITOR_MENU. Чтобы зарегистрировать меню в программе 
			необходимо в приложении реализовать метод CreateMenus():</P>
		<PRE><FONT color=#990033>void CMyEditorAppSpecific::CreateMenus( IMainFrame *pMainFrame )
{
	AfxSetResourceHandle( theMyDLLInstance );
	vector<UINT> nIDs;
	nIDs.push_back( IDM_MAIN_MENU );
	nIDs.push_back( IDM_MY_EDITOR_MENU );
	pMainFrame-&gt;AddMenuResources( nIDs );
	AfxSetResourceHandle( AfxGetInstanceHandle() );
}</FONT></PRE>
		<P>Программа автоматически включит первое из перечисленных меню при старте программы.
			Так как меню задаются не вектором а эллиптической функцией сейчас поддерживаются 20 различных 
			меню. Если необходимо больше меню – скажите, добавим. Чтобы включать меню при старте редактора необходимо 
			вызвать следующее:</P>
		<PRE><FONT color=#990033>void CMyEditor::Create()
{
	IMainFrame *pMainFrame = Singleton &lt;IMainFrameContainer&gt;()-&gt;Get();
	…
	AfxSetResourceHandle( theMyDLLInstance );
	pMainFrame-&gt;ShowMenu( IDM_MY_EDITOR_MENU );
	AfxSetResourceHandle( AfxGetInstanceHandle() );
	…
}</FONT></PRE>
		<P>Чтобы восстановить основное меню необходимо вызвать следующее:</P>
		<PRE><FONT color=#990033>void CMyEditor::Destroy()
{
	if ( Singleton&lt;IMainFrameContainer&gt;() &amp;&amp;
	     Singleton&lt;IMainFrameContainer&gt;()-&gt;Get() &amp;&amp; 
	     Singleton&lt;IMainFrameContainer&gt;()-&gt;GetSECWorkbook() )
	{
		IMainFrame *pMainFrame = Singleton&lt;IMainFrameContainer&gt;()-&gt;Get();
		…
		AfxSetResourceHandle( theMyDLLInstance );
		pMainFrame-&gt;ShowMenu( IDM_MAIN_MENU );
		AfxSetResourceHandle( AfxGetInstanceHandle() );
		…
	}
}</FONT></PRE> 
	</BODY>
</HTML>
