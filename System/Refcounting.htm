<HTML>
	<HEAD>
		<TITLE></TITLE>
		<META NAME="GENERATOR" Content="Microsoft Visual Studio .NET 7.1">
	</HEAD>
	<BODY>
		<P>Зачем это нужно? Основная цель - избавиться от ошибок, связанных с выделением и 
			освобождением памяти. Наиболее распространены два вида ошибок - утечки памяти и 
			провисшие указатели. Утечки памяти - ситуация, когда память была выделена, 
			после чего перестала использоваться, но освободить ее забыли. Провисшие 
			указатели - указатели, которые указывают на неверное место. Самый простой 
			способ получить провисший указатель - освободить память по указателю, а сам 
			указатель оставить неизменным. Эти ошибки плохи тем, что они не всегда 
			повторяются, а когда происходят зачастую приводят к фатальным последствиям для 
			программы. Для решения этих проблем можно использовать механизмы автоматической 
			"сборки мусора" (освобождения неиспользуемой памяти).
		</P>
		<P>Альтернативные подходы к управлению распределением памяти:</P>
		<UL>
			<LI>
			ручное освобожднеие памяти. При правильном применении программы с таким методом 
			работают быстрее. Практика наглядно показала, что метод дает слабый прирост 
			производительности, а правильное применение этого метода очень 
			сложно.&nbsp;Масса времени при таком подходе тратится непроизводительно на 
			написание кода по освобождению памяти и еще больше на поиск ошибок в этом 
			освобождении.
			<LI>
			проход по графу объектов. Идея в том, что все объекты программы представляют 
			собой узлы графа, указатели - ребра графа. Граф направленный. Есть "корневые" 
			объекты - те объекты, которые должны существовать, даже если на них никто не 
			ссылается. После этого, если в графе есть объекты, в которые нельзя попасть из 
			корневых объектов, то такой объект может быть освобожден. Подход неплохой, но у 
			него есть пара недостатков. Первый - проход по всем объектам в поисках тех, на 
			кого нет ссылок может занимать значительное время. Второй - для того, чтобы 
			осуществить проход мы должны знать какие участки в памяти являются указателями. 
			Так как в с++ нет способа узнать информацию о типе в процессе исполнения, то 
			для реализации такого подхода нужно каким-то способом такую информацию 
			получить. Простого способа получения этой информации найти не удалось. Из-за 
			этих двух недостатков мы не используем этот метод.
			<LI>
				подсчет ссылок. Идея в том, что для каждого объекта заводится количество ссылок 
				- количество ссылающихся на этот объект указателей. Когда это число будет равно 
				нулю объект можно удалять. Использование этого подхода требует добавить в 
				каждый объект, память под который выделяется в куче добавить поле - количество 
				ссылок. Все обычные указатели должны быть заменены на "умные указатели" (smart 
				pointers), которые осуществляют подсчет ссылок при создании / копировании / 
				уничтожении / присваивании. Использование обычных указателей при таком подходе 
				недопустимо (за исключением особых случаев, которые обсуждены далее), так как 
				может привести к утечкам памяти и провисшим указателям</LI></UL>
		<P>Как можно догадаться из названия документа у нас используется подход, основанный 
			на подсчете ссылок. Для того, чтобы у каждого объекта в куче было поле с 
			количеством ссылок его нужно наследовать от <STRONG>CObjectBase</STRONG>. Умные 
			указатели в нашем случае - шаблон <STRONG>CPtr&lt;T&gt;</STRONG>. Сразу после 
			new у объекта количество ссылок равно нулю. После присвоения какому-нибудь 
			CPtr&lt;&gt; указателя на объект количество ссылок увеличивается на единицу. 
			После прекращения существования CPtr&lt;&gt; или присвоения CPtr&lt;&gt;`у 
			другого значения количество ссылок уменьшается на единицу. Когда количество 
			ссылок достигает нуля объект удаляется с помощью конструкции delete this. Чтобы 
			она работала у CObjectBase объявлен виртуальный деструктор.</P>
		<P>При использовании умных указателей только одного типа (например, CPtr&lt;&gt;) 
			мы быстро получаем проблему, связанную с&nbsp;"кольцевыми ссылками" - ситуация, 
			когда несколько объектов ссылаются друг на друга по кругу. Из-за того, что 
			объекты как бы "поддерживают" друг друга ни один из них не достигает 
			состояния&nbsp;с нулевым количеством ссылок. Получается утечка памяти. Эту 
			проблему можно решить введением второго типа указателей (у нас это <STRONG>CObj&lt;&gt;</STRONG>). 
			Соотвественно, у каждого объкта будет не один счетчик ссылок, а два. Память под 
			объект освобождается когда кончаются ссылки обоих типов. Когда кончаются ссылки 
			типа CObj&lt;&gt; объект переводится&nbsp;в специальное "невалидное" состояние 
			и его содержимое сбрасывается в состояние по умолчанию (в том числе обнуляются 
			все указатели на другие объекты). "Невалидное" состояние означает, что объект 
			на самом деле уже "мертв", но память под него еще не освобождена, чтобы 
			недопустить "провисших указателей". "Невалидное" состояние объекта можно 
			определить с помощью функции IsValid(). Теперь, если граф связей объектов по 
			указателям CObj&lt;&gt; не содержит циклов, то все объекты могут быть приведены 
			в "невалидное" состояние, что автоматически означает, что память под них будет 
			освобождена, так как при переводе в "невалидное" состояние сбрасываются все 
			указатели (в том числе и CPtr&lt;&gt;) всех объектов в 0.</P>
		<P>Сброс объекта в состояние по умолчанию осуществляется с помощью 
			последовательного вызова деструктора и конструктора по умолчанию. В частности 
			это означает, что у каждого финального типа - наследника CObjectBase должен 
			быть конструктор по умолчанию. Сброс осуществляется с помощью функции <STRONG>DestroyContents()</STRONG>, 
			которая определяется в макросах OBJECT_BASIC_METHODS и OBJECT_NOCOPY_METHODS. 
			Звать DestroyContents() напрямую нельзя, для этого предназначена функция <STRONG>Clear()</STRONG></P>
		<P>Возможны ситуации, когда двух типов умных указателей будет недостаточно. В 
			частности, это ситуации, когда время жизни объекта определяется двумя 
			факторами. Например, время жизни текстуры в DirectX определяется 
			пользователем&nbsp;- он может решить, что ему текстура больше не нужна и 
			удалить последний CObj&lt;&gt; на нее. Но, текстура также может быть удалена 
			из-за того, что произошла смена режима работы DirectX, например, с 
			полноэкранного на оконный. Для решения этой проблемы был добавлен третий тип 
			указателя - <STRONG>CMObj&lt;&gt;</STRONG>, по сути эквивалентный CObj&lt;&gt;. 
			Теперь у объекта 3 счетчика ссылок. Объект переводится в "невалидное" состояние 
			как при обнулении количества ссылок типа&nbsp;CObj&lt;&gt;, так и при обнулении 
			количества ссылок типа CMObj&lt;&gt;. Это позволяет более гибко управлять 
			временем жизни, но это накладывает некоторые ограничения на работу с такими 
			объектами. В частности, если на объект есть только указатели типа 
			CObj&lt;&gt;&nbsp;и CPtr&lt;&gt;, и мы всем указателям типа CObj&lt;&gt; 
			присваиваем "валидные" объекты (что, как правило, так), то нам гарантируется, 
			что объект, на который указывает CObj&lt;&gt; является "валдным". При 
			использовании&nbsp;&nbsp;CObj&lt;&gt; и CMObj&lt;&gt; одновременно это не так, 
			поэтому широкое использование этого подхода не рекомендуется.</P>
		<P>Таким образом для того, чтобы использовать механизм подсчета ссылок необходимо 
			наследовать все объекты, находящиеся в куче от CObjectBase и все указатели на 
			них сделать умными. Кроме этого в финальных классах необходимо вписать один из 
			макросов OBJECT_BASIC_METHODS и OBJECT_NOCOPY_METHODS. Оба эти макроса 
			определяют функцию DestroyContents() (используется при переводе объекта в 
			"невалидное" состояние) Различие между этими макросами следующее:<BR>
			<STRONG>OBJECT_BASIC_METHODS</STRONG> - определяет функцию <STRONG>Duplicate()</STRONG>, 
			производящую копирование обеъкта (копирование по полям с помощью конструктора 
			копирования). Чтобы это работало&nbsp;нужно, чтобы все поля имели корректные 
			конструкторы&nbsp;копирования / операторы присваивания. В макросе 
			OBJECT_BASIC_METHODS также автоматически определяется пустой деструктор, так 
			как объекты с нетривиальным деструктором, как правило, не могут быть 
			скопированы с помощью конструктора копирования по умолчанию<BR>
			<STRONG>OBJECT_NOCOPY_METHODS </STRONG>- как следует из названия этот макрос не 
			объявляет функцию копирования, но он и не объявляет деструктор, поэтому его 
			можно использовать в тех случаях, когда объект обладает нетривиальным 
			деструктором или просто когда копирование этого объекта не требуется. 
			Деструктор следует делать private, так как если его сделать public, то 
			компилятор позволит создать такой объект на стеке, после чего весь механизм 
			подсчета ссылок будет не нужен и даже вреден, так как может попытаться удалить 
			объект на стеке с помощью оператора delete, что приведет к непредсказуемым 
			последствиям.</P>
		<P>Функция CObjectBase::virtual int operator&amp;( interface IBinSaver &amp;f ) { 
			return 0; } нужна для системы сериализации.
		</P>
		<P><STRONG>Tips:</STRONG></P>
		<UL>
			<LI>
			При множественном наследовании все наследования от CObjectBase должны быть 
			виртуальными
			<LI>
			Утечки памяти возможны в системе с подсчетом ссылок для этого достаточно 
			создать кольцо из объектов, ссылающихся друг на друга с помощью CObj&lt;&gt;
			<LI>
			Неожиданный способ создать утечку памяти - создавать в конструкторе по 
			умолчанию некий объект, который будет ссылаться на конструируемый объект по 
			CObj&lt;&gt; или CPtr&lt;&gt;. Такая конструкция не может быть удалена с 
			помощью механизма приведения в "невалидное" состояние и получается 
			утечка&nbsp;памяти.
			<LI>
				Не стоит делать лишних прибавлений / вычитаний ссылок&nbsp;- заводить временных 
				переменные - умные указатели или использовать умные указатели в качестве 
				возвращаемого значения<BR>
				<FONT face="Courier New" color="#0000ff">CPtr&lt;CSomeObj&gt; func()&nbsp; {...} // 
					неудачно, так как создается лишний CPtr&lt;&gt;<BR>
					CSomeObj *func()&nbsp; {...} // ok<BR>
					...<BR>
					{<BR>
					&nbsp; // если GetCurrentObj() не создает объект, а просто его возвращает, то 
					использование&nbsp;<BR>
					&nbsp; // умного указателя в данном случае излишне, можно было обойтись простым<BR>
					&nbsp; CPtr&lt;CSomeObj&gt; p = GetCurrentObj();&nbsp;<BR>
					&nbsp; p-&gt;func();<BR>
					}</FONT>
			<LI>
			Текущая реализация подсчета ссылок не поддерживает треды. Безопасная с точки 
			зрения тредов реализация должна была бы локать количество ссылок при каждом 
			изменении (примерно в 100 раз медленнее, чем без лока). Кроме этого логика 
			перевода объекта в "невалидное" состояние резко усложнилась бы.
			<LI>
			Почему функция IsRefInvalid() возвращает int, а не bool?&nbsp;Дело в том, что 
			если она будет возвращать bool, то компилятор будет генерировать код для 
			перевода&nbsp;&nbsp;int в bool и не будет его убирать, даже если функция 
			подставляется inline и все для чего используется этот&nbsp;bool - условный 
			переход. Чтобы избежать генерации этого кода&nbsp;функция возвращает int. 
			Благодаря возможности&nbsp;С++ использовать int там, где требуется bool, ее 
			использование от этого не меняется. По этой же причине использование 
			IsRefValid() - потеря производительности - оператор ! также не оптимизируется в 
			этом случае.
			<LI>
			Не стоит переопределять operator new в объектах, так&nbsp;как удалятся они 
			будут с помощью стандартного operator`a delete (из-за delete this в 
			CObjectBase)
			<LI>
			Наследование от CObj/CPtr рассматривается как читерство,&nbsp;так как позволяет 
			обойти подсчет ссылок
			<LI>
				Рекомендуется во первых не наследовать одних финальных классов от других 
				(например, не наследовать "анимированный объект" от "просто объекта"). Макросы 
				OBJECT_BASIC_METHODS или OBJECT_NOCOPY_METHODS лучше писать только в финальном 
				классе, от которого никто не наследует. Иначе можно забыть написать макрос в 
				наследнике и ошибки компиляции при этом не будет, но работать все будет 
				неправильно.</LI></UL>
	</BODY>
</HTML>
